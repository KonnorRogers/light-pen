{
  "version": 3,
  "sources": ["../../../../../exports/light-editor.styles.js", "../../../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directive-helpers.ts", "../../../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directives/live.ts", "../../../../../exports/light-editor.js"],
  "sourcesContent": ["import { css } from \"lit\"\n\nexport const styles = css`\n  [part~=\"editor\"] {\n    display:grid;\n    grid-template-columns: minmax(0, 1fr);\n    grid-template-rows: minmax(0, 1fr);\n    column-gap: 0;\n    row-gap: 0;\n    position: relative;\n    padding-top: 3px;\n  }\n\n  [part~=\"textarea\"] {\n    position: relative;\n    color: transparent;\n    background-color: transparent;\n    caret-color: black;\n    z-index: 1;\n    resize: vertical;\n  }\n\n  [part~=\"pre\"],\n  [part~=\"textarea\"] {\n    grid-area:1/1/2/2;\n    margin-bottom:0;\n    min-height:15em;\n    margin: 0;\n    padding: 0;\n\t  display: block;\n\t  line-height: 1.5;\n    padding: 8px;\n    border: none;\n    overflow: auto;\n    position: relative;\n\n    /* this creates line-wrapping. */\n\t  word-break: break-word;\n    white-space: pre-wrap;\n\n    /* No wrapping */\n\t  /* word-break: break-all; */\n    /* white-space: pre; */\n    tab-size: 2;\n  }\n\n  [part~=\"pre\"],\n  [part~=\"code\"] {\n\t  color: #272727;\n\t  background-color: #f7f7f7;\n  }\n\n  [part~=\"pre\"],\n  [part~=\"code\"],\n  [part~=\"textarea\"] {\n\t  font-family: Menlo, Monaco, \"Courier New\", monospace;\n\t  font-size: 0.875rem;\n  }\n`\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  _$LH,\n  Part,\n  DirectiveParent,\n  TemplateResult,\n  CompiledTemplateResult,\n} from './lit-html.js';\nimport {\n  DirectiveResult,\n  DirectiveClass,\n  PartInfo,\n  AttributePartInfo,\n} from './directive.js';\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\n\nconst {_ChildPart: ChildPart} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\n\nexport const TemplateResultType = {\n  HTML: 1,\n  SVG: 2,\n} as const;\n\nexport type TemplateResultType =\n  (typeof TemplateResultType)[keyof typeof TemplateResultType];\n\ntype IsTemplateResult = {\n  (val: unknown): val is TemplateResult | CompiledTemplateResult;\n  <T extends TemplateResultType>(\n    val: unknown,\n    type: T\n  ): val is TemplateResult<T>;\n};\n\n/**\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\n */\nexport const isTemplateResult: IsTemplateResult = (\n  value: unknown,\n  type?: TemplateResultType\n): value is TemplateResult =>\n  type === undefined\n    ? // This property needs to remain unminified.\n      (value as TemplateResult)?.['_$litType$'] !== undefined\n    : (value as TemplateResult)?.['_$litType$'] === type;\n\n/**\n * Tests if a value is a CompiledTemplateResult.\n */\nexport const isCompiledTemplateResult = (\n  value: unknown\n): value is CompiledTemplateResult => {\n  return (value as CompiledTemplateResult)?.['_$litType$']?.h != null;\n};\n\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value: unknown): value is DirectiveResult =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'] !== undefined;\n\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value: unknown): DirectiveClass | undefined =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'];\n\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part: PartInfo) =>\n  (part as AttributePartInfo).strings === undefined;\n\nconst createMarker = () => document.createComment('');\n\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (\n  containerPart: ChildPart,\n  refPart?: ChildPart,\n  part?: ChildPart\n): ChildPart => {\n  const container = wrap(containerPart._$startNode).parentNode!;\n\n  const refNode =\n    refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(\n      startNode,\n      endNode,\n      containerPart,\n      containerPart.options\n    );\n  } else {\n    const endNode = wrap(part._$endNode!).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      part._$reparentDisconnectables?.(containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (\n        part._$notifyConnectionChanged !== undefined &&\n        (newConnectionState = containerPart._$isConnected) !==\n          oldParent!._$isConnected\n      ) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start: Node | null = part._$startNode;\n      while (start !== endNode) {\n        const n: Node | null = wrap(start!).nextSibling;\n        wrap(container).insertBefore(start!, refNode);\n        start = n;\n      }\n    }\n  }\n\n  return part;\n};\n\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = <T extends ChildPart>(\n  part: T,\n  value: unknown,\n  directiveParent: DirectiveParent = part\n): T => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n\n// A sentinel value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part: Part, value: unknown = RESET_VALUE) =>\n  (part._$committedValue = value);\n\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being committed.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part: ChildPart) => part._$committedValue;\n\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part: ChildPart) => {\n  part._$notifyConnectionChanged?.(false, true);\n  let start: ChildNode | null = part._$startNode;\n  const end: ChildNode | null = wrap(part._$endNode!).nextSibling;\n  while (start !== end) {\n    const n: ChildNode | null = wrap(start!).nextSibling;\n    (wrap(start!) as ChildNode).remove();\n    start = n;\n  }\n};\n\nexport const clearPart = (part: ChildPart) => {\n  part._$clear();\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange, nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {isSingleExpression, setCommittedValue} from '../directive-helpers.js';\n\nclass LiveDirective extends Directive {\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      !(\n        partInfo.type === PartType.PROPERTY ||\n        partInfo.type === PartType.ATTRIBUTE ||\n        partInfo.type === PartType.BOOLEAN_ATTRIBUTE\n      )\n    ) {\n      throw new Error(\n        'The `live` directive is not allowed on child or event bindings'\n      );\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n\n  render(value: unknown) {\n    return value;\n  }\n\n  override update(part: AttributePart, [value]: DirectiveParameters<this>) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === (element as any)[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {LiveDirective};\n", "import { html } from \"lit\";\nimport { BaseElement } from \"../internal/base-element.js\";\nimport { baseStyles } from \"./base-styles.js\";\nimport { styles } from \"./light-editor.styles.js\";\nimport { theme } from \"./default-theme.styles.js\";\nimport { live } from \"lit/directives/live.js\";\n\nimport HighlightJS from 'highlight.js/lib/core';\nimport JavaScript from 'highlight.js/lib/languages/javascript';\nimport HTML from 'highlight.js/lib/languages/xml';\nimport CSS from 'highlight.js/lib/languages/css';\nimport { unsafeHTML } from \"lit/directives/unsafe-html.js\";\nimport { dedent } from \"../internal/dedent.js\";\n\nHighlightJS.registerLanguage('javascript', JavaScript);\nHighlightJS.registerLanguage('xml', HTML);\nHighlightJS.registerLanguage('css', CSS);\n\n/**\n * A bare bones plain text editor with syntax highlighting.\n * @customElement\n * @tagname light-editor\n *\n */\nexport default class LightEditor extends BaseElement {\n  static baseName = \"light-editor\"\n\n  static styles = [\n    baseStyles,\n    styles,\n    theme,\n  ]\n\n  // One day.\n  // static formAssociated = true\n\n  static properties = {\n    label: {},\n    value: {},\n    language: {reflect: true}\n  }\n\n  constructor () {\n    super()\n\n    /**\n     * @type {string}\n     */\n    this.language = 'xml'\n\n    /**\n     * @type {string}\n     */\n    this.value = ''\n  }\n\n\n  render () {\n    const language = this.language\n\n    const highlightedCode = this.value ? unsafeHTML(this.highlightCode({ code: this.value, language })) : \"\"\n\n    return html`\n\t\t\t<div class=\"editor\" part=\"editor\">\n        <!-- This is where the fancy syntax highlighting comes in -->\n\t\t\t\t<pre\n          id=\"pre-${language}\"\n          data-code-lang=${language}\n          aria-hidden=\"true\"\n          part=\"pre pre-${language}\"\n        ><code\n            part=\"code code-${language}\"\n            class=\"language-${language}\"\n          >${highlightedCode}</code></pre>\n        <!-- IMPORTANT! There must be no white-space above. -->\n\t\t\t\t<textarea\n          id=\"textarea-${language}\"\n          data-code-lang=${language}\n          part=\"textarea textarea-${language}\"\n          spellcheck=\"false\"\n          autocorrect=\"off\"\n          autocapitalize=\"off\"\n          translate=\"no\"\n          @keydown=${this.keydownHandler}\n          @input=${this.syncScroll}\n          @input=${/** @param {Event} e */ (e) => {\n            this.value = /** @type {HTMLTextAreaElement} */ (e.currentTarget).value\n            this.dispatchEvent(new Event(\"light-input\", { bubbles: true, composed: true }))\n          }}\n          @change=${/** @param {Event} e */ (e) => {\n            this.value = /** @type {HTMLTextAreaElement} */ (e.currentTarget).value\n            this.dispatchEvent(new Event(\"light-change\", { bubbles: true, composed: true }))\n          }}\n          @scroll=${this.syncScroll}\n          value=${this.value}\n        >${this.value}</textarea>\n\t\t\t</div>\n\t\t`\n  }\n\n  /**\n   * @param {Event} e\n   */\n  handleSlotChangeEvent (e) {\n    const target = /** @type {HTMLSlotElement} */ (e.target)\n\n    this.currentWatchedElements = target.assignedElements({ flatten: true })\n    // @TODO: Attach mutations observers to update value.\n  }\n\n  /**\n   * @internal\n   * @param {Event} e\n   */\n  syncScroll (e) {\n    /**\n     * @type {null | HTMLTextAreaElement}\n     */\n    // @ts-expect-error\n    const textarea = e.target\n\n    if (textarea == null) return\n\n    const pre = this.shadowRoot?.querySelector(`pre`)\n\n    if (pre == null) return\n\n    pre.scrollTop = textarea.scrollTop;\n    pre.scrollLeft = textarea.scrollLeft;\n  }\n\n  /**\n   * @param {KeyboardEvent} evt\n   */\n  keydownHandler(evt) {\n    /**\n     * @type {HTMLTextAreaElement}\n     */\n    // @ts-expect-error\n    const target = evt.target\n\n    if ('Tab' === evt.key) {\n      evt.preventDefault()\n      return target.setRangeText('\\t', target.selectionStart, target.selectionEnd, 'end')\n    }\n  }\n\n  /**\n   * Override this to use a highlighter of your choice.\n   * @param {{code: string, language: string}} options\n   */\n  highlightCode (options) {\n    let { code, language } = options\n\n    // const highlightJsLanguage = /** @type {typeof LightPen} */ (this.constructor).languageMap[language]\n\n    code = this.unescapeCharacters(code)\n    code = dedent(code)\n    code = this.injectNewLine(code)\n\n    return HighlightJS.highlight(code, {language}).value\n  }\n\n  /**\n   * @param {string} text\n   */\n  unescapeCharacters (text) {\n    // Update code\n    return text.replaceAll(\"&lt;/script>\", \"</script>\")\n  }\n\n  /**\n   * Highlighters strip newlines. But you can see new lines in <textarea>, this fixes that.\n   * @param {string} text\n   */\n  injectNewLine (text) {\n    // Handle final newlines (see article)\n    if(text[text.length-1] == \"\\n\") { // If the last character is a newline character\n      text += \"\\n\"; // Add a placeholder space character to the final line\n    }\n\n    return text\n  }\n\n}\n\n"],
  "mappings": "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",
  "names": ["styles", "i", "_ChildPart", "ChildPart", "_$LH", "isSingleExpression", "part", "strings", "RESET_VALUE", "setCommittedValue", "part", "value", "_$committedValue", "live", "directive", "Directive", "constructor", "partInfo", "super", "type", "PartType", "PROPERTY", "ATTRIBUTE", "BOOLEAN_ATTRIBUTE", "Error", "isSingleExpression", "render", "value", "update", "part", "noChange", "nothing", "element", "name", "hasAttribute", "getAttribute", "String", "setCommittedValue", "core_default", "javascript", "xml", "css", "LightEditor", "BaseElement", "language", "highlightedCode", "o", "x", "e", "target", "textarea", "pre", "evt", "options", "code", "dedent", "text", "__publicField", "baseStyles", "styles", "theme"]
}
