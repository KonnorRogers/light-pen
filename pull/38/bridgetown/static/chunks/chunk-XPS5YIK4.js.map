{
  "version": 3,
  "sources": ["../../../../../exports/components/light-editor/light-editor.styles.js", "../../../../../internal/base-event.js", "../../../../../exports/events/light-resize-event.js", "../../../../../exports/components/light-editor/light-editor.js"],
  "sourcesContent": ["import { css } from \"lit\";\n\nexport const styles = css`\n  [part~=\"base\"] {\n    font-family: Menlo, Monaco, \"Courier New\", monospace;\n    font-size: 1rem;\n    height: 15em;\n    width: 100%;\n    max-width: 100%;\n    max-height: 100%;\n    position: relative;\n    overflow: hidden;\n    resize: both;\n    font-size: normal;\n    font-family: monospace;\n    line-height: 1.5; /* Inherited to child elements */\n    tab-size: 2;\n    caret-color: black;\n    counter-reset: linenumber 0;\n    border: 1px solid gray;\n  }\n\n  /* Include \"pre\" if line numbers are disabled */\n  :host([disable-line-numbers]) [part~=\"textarea\"],\n  [part~=\"textarea\"],\n  light-code::part(line) {\n    padding-inline-start: 8px;\n    padding-inline-end: 8px;\n  }\n\n  [part~=\"textarea\"] {\n    color: transparent;\n    /* color: rgba(255,0,0,0.5); */\n    background-color: transparent;\n    caret-color: inherit;\n    z-index: 1;\n    resize: none;\n    padding: 0;\n\n    /* Dynamically generated based on the size of the  gutter from \"<light-code>\" */\n    padding-inline-start: calc(var(--gutter-width, 40px) + 8px);\n\n    /* needs to match light-codes padding-inline-end */\n    padding-inline-end: 8px;\n  }\n\n  light-code {\n    pointer-events: none;\n  }\n\n  light-code::part(pre) {\n    border-color: transparent;\n    position: relative;\n  }\n\n  light-code::part(line)::before {\n    content: \"\";\n    line-height: inherit;\n    padding-inline-end: 0px;\n  }\n\n  [part~=\"base\"]:focus-within {\n    border-color: dodgerblue;\n    outline: 2px solid dodgerblue;\n  }\n\n  [part~=\"textarea\"]:focus {\n    outline: transparent;\n  }\n\n  light-code::part(line) {\n    padding-inline-start: 8px;\n  }\n\n  light-code::part(pre),\n  [part~=\"textarea\"],\n  light-code::part(code) {\n    /* I don't love this, but it fixes font size inconsistencies on mobile. The alternative is listen for font-size changes, which is...challenging. */\n    -webkit-text-size-adjust: 100%;\n    -moz-text-size-adjust: 100%;\n    text-size-adjust: 100%;\n\n    font-size: inherit;\n    font-family: inherit;\n    line-height: inherit;\n    tab-size: inherit;\n  }\n\n  [part~=\"textarea\"] {\n    /* this creates \"soft\" line-wrapping. */\n    word-break: break-word;\n    white-space: pre-wrap;\n  }\n\n  :host([wrap=\"hard\"]) [part~=\"textarea\"] {\n    /* this would remove line-wrapping */\n    word-break: break-all;\n    white-space: pre;\n  }\n\n  [part~=\"base\"]:focus-within light-code::part(line-highlight) {\n    background-color: rgba(255, 255, 209, 1);\n  }\n\n  [part~=\"base-editor\"] {\n    position: relative;\n    display: grid;\n    grid-template-columns: minmax(0, 1fr);\n    grid-template-rows: minmax(0, 1fr);\n    max-height: 100%;\n    min-height: 100%;\n  }\n\n  light-code,\n  [part~=\"textarea\"] {\n    grid-area: 1/1/2/2;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    border: none;\n    overflow: auto;\n    border: none;\n  }\n\n  [part~=\"textarea\"]::placeholder {\n    color: rgba(0, 0, 0, 0.5);\n  }\n\n  [part~=\"textarea\"]::selection {\n    color: inherit;\n    background-color: rgba(0, 0, 0, 0.15);\n  }\n`;\n", "export class BaseEvent extends Event {\n  /**\n   * @param {string} name\n   * @param {EventInit} [options={}]\n   */\n  constructor(name, options = {}) {\n    if (options.bubbles == null) options.bubbles = true;\n    if (options.composed == null) options.composed = true;\n    super(name, options);\n  }\n}\n", "// @ts-check\nimport { BaseEvent } from \"../../internal/base-event.js\";\n\nexport class LightResizeEvent extends BaseEvent {\n  /**\n   * @param {\"light-resize\" | Omit<string, \"light-resize\"> & string} [name=\"light-resize\"]\n   * @param {Partial<EventInit & { height: number, width: number }>} [options={}]\n   */\n  constructor(name = \"light-resize\", options = {}) {\n    super(name, options);\n\n    this.height = options.height;\n    this.width = options.width;\n  }\n}\n", "// @ts-check\nimport { html, LitElement } from \"lit\";\nimport { ref } from \"lit/directives/ref.js\";\nimport { LitTextareaMixin } from \"form-associated-helpers/exports/mixins/lit-textarea-mixin.js\";\n\nimport { baseStyles } from \"../../styles/base-styles.js\";\nimport { theme } from \"../../styles/default-theme.styles.js\";\nimport { styles } from \"./light-editor.styles.js\";\n\nimport { LightResizeEvent } from \"../../events/light-resize-event.js\";\n\nimport { dedent } from \"../../../internal/dedent.js\";\nimport { BaseElement } from \"../../../internal/base-element.js\";\nimport { elementsToString } from \"../../../internal/elements-to-strings.js\";\nimport { createPrismInstance } from \"../../../internal/prism-highlight.js\";\n\nimport LightCode from \"../light-code/light-code.js\";\n\nconst newLineRegex = /\\r\\n?|\\n/g;\n\n/**\n * A minimal plain text editor with syntax highlighting, line numbers, and line highlighting.\n *    `<light-editor>` is not intended to replace full solutions like CodeMirror, but it\n *    is a lightweight alternative using a `<pre>` overlaid on top of a `<textarea>`\n *    and a few extra divs to make for an enjoyable text editing experience.\n *\n * @customElement\n * @tagname light-editor\n *\n * @event {Event} light-input - Re-emits the textarea's \"input\" event\n * @event {Event} light-change - Re-emits the textarea's \"change\" event\n * @event {Event} light-selectionchange - Re-emits the textarea's \"selectionchange\" event\n * @event {Event} light-focus - Re-emits the textarea's \"focus\" event\n * @event {Event} light-blur - Re-emits the textarea's \"blur\" event\n * @event {Event} light-resize - Is emitting whenever the editor resizes.\n * @event {Event} light-value-change - Emitted whenever the \"value\" attribute of the editor changes.\n *\n */\nexport default class LightEditor extends LitTextareaMixin(BaseElement) {\n  /**\n   * @override\n   */\n  static baseName = \"light-editor\";\n\n  /**\n   * @override\n   */\n  static dependencies = { \"light-code\": LightCode };\n\n  /**\n   * @override\n   * Without delegatesFocus, we get this fun message:\n   *  \"The invalid form control with name='editor' is not focusable.\"\n   */\n  static shadowRootOptions = {\n    ...LitElement.shadowRootOptions,\n    delegatesFocus: true,\n  };\n\n  /**\n   * @override\n   */\n  static styles = [baseStyles, styles, theme];\n\n  /**\n   * @override\n   */\n  static properties = {\n    ...LitTextareaMixin.formProperties,\n    wrap: { reflect: true, state: false },\n    language: { reflect: true },\n    src: {},\n    disableLineNumbers: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"disable-line-numbers\",\n    },\n    preserveWhitespace: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"preserve-whitespace\",\n    },\n    hasFocused: {\n      type: Boolean,\n      reflect: true,\n      attribute: \"data-has-focused\",\n    },\n    currentLineNumber: {\n      attribute: false,\n      state: true,\n      type: Number,\n    },\n    highlighter: {\n      attribute: false,\n      state: true,\n    },\n  };\n\n  constructor() {\n    super();\n\n    /**\n     * The language used for highlighting. Default is \"html\". \"css\" and \"js\" also included by default.\n     * @type {string}\n     */\n    this.language = \"html\";\n\n    /**\n     * The value to set for the text editor\n     * @type {string}\n     */\n    this.value = \"\";\n\n    /**\n     * This is the value attribute. This is used for resetting the form input.\n     * @type {string}\n     */\n    this.defaultValue = \"\";\n\n    /**\n     * The underlying textarea\n     * @type {null | HTMLTextAreaElement}\n     */\n    this.textarea = null;\n\n    /**\n     * Points to a remote file source that should be accessible via `fetch()`\n     * @type {string | null}\n     */\n    this.src = null;\n\n    /**\n     * @property\n     * @type {\"soft\" | \"hard\"}\n     * If `wrap=\"soft\"`, lines will wrap when they reach the edge of their container. If `wrap=\"hard\"`, lines will not wrap instead all the user to scroll horizontally to see more code.\n     */\n    this.wrap = \"soft\";\n\n    /**\n     * Whether to strip whitespace before first character, and after the last character.\n     * @type {boolean}\n     */\n    this.preserveWhitespace = false;\n\n    /**\n     * @type {boolean}\n     */\n    this.disableLineNumbers = false;\n\n    /**\n     * Points to an instance of Prism from \"prism-esm\" for adjusting highlighting, adding plugins, etc.\n     * @type {ReturnType<typeof createPrismInstance>}\n     */\n    this.highlighter = createPrismInstance();\n\n    /**\n     * @type {number}\n     */\n    this.currentLineNumber = 1;\n  }\n\n  /**\n   * @override\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    this.value = this.getAttribute(\"value\") || \"\";\n    this.defaultValue = this.getAttribute(\"value\") || \"\";\n\n    if (\n      this.value === this.getAttribute(\"value\") &&\n      this.preserveWhitespace !== true\n    ) {\n      // Remove only lines that are blank with spaces that are blank. trim() removes preceding white-space for the line with characters.\n      // https://stackoverflow.com/questions/14572413/remove-line-breaks-from-start-and-end-of-string#comment104290392_14572494\n      this.value = dedent(\n        this.value.replace(/(^\\s*(?!.+)\\n+)|(\\n+\\s+(?!.+)$)/g, \"\"),\n      ).trim();\n    }\n  }\n\n  /**\n   * @override\n   * @param {import(\"lit\").PropertyValues<typeof this>} changedProperties\n   */\n  willUpdate(changedProperties) {\n    if (changedProperties.has(\"value\")) {\n      // Emit events on value updates\n      this.dispatchEvent(\n        new Event(\"light-value-change\", { bubbles: true, composed: true }),\n      );\n\n      this.dispatchEvent(\n        new Event(\"change\", { bubbles: true, composed: true }),\n      );\n    }\n\n    if (changedProperties.has(\"src\") && this.src) {\n      fetch(this.src).then(async (response) => {\n        let finalValue = await response.text();\n\n        if (this.preserveWhitespace !== true) {\n          finalValue = dedent(\n            finalValue.replace(/(^\\s*(?!.+)\\n+)|(\\n+\\s+(?!.+)$)/g, \"\"),\n          ).trim();\n        }\n\n        return finalValue;\n      });\n    }\n\n    super.willUpdate(changedProperties);\n  }\n\n  /**\n   * @override\n   */\n  click() {\n    if (this.textarea) {\n      this.textarea.click();\n    } else {\n      this.click();\n    }\n  }\n\n  /**\n   * @override\n   * @param {FocusOptions} [options]\n   */\n  focus(options) {\n    if (this.textarea) {\n      this.textarea.focus(options);\n    } else {\n      this.focus(options);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  __setGutterWidth() {\n    const gutterWidth = /** @type {undefined | null | HTMLElement} */ (\n      this.shadowRoot\n        ?.querySelector(\"light-code\")\n        ?.shadowRoot?.querySelector(\"[part~='gutter']\")\n    )?.offsetWidth;\n\n    if (gutterWidth) {\n      this.style.setProperty(\"--gutter-width\", `${gutterWidth}px`);\n      return;\n    }\n\n    this.style.removeProperty(\"--gutter-width\");\n  }\n\n  /**\n   * @override\n   */\n  render() {\n    const language = this.language;\n    this.syncScroll();\n\n    setTimeout(async () => {\n      await this.updateComplete;\n      this.__setGutterWidth();\n    });\n\n    return html`\n      <div part=\"base\">\n        <!-- This is where the fancy syntax highlighting comes in -->\n        <div part=\"base-editor\">\n          <!-- This bad boy is for measuring cursors -->\n          <pre\n            part=\"pre\"\n            aria-hidden=\"true\"\n            style=\"\n              position: fixed;\n              top: 0;\n              left: 0;\n              pointer-events: none;\n              visibility: hidden;\n            \"\n          ><code part=\"code\"><span id=\"before-caret\"></span><span id=\"caret\">.</span><span id=\"after-caret\">.</span></code></pre>\n\n          <light-code\n            tabindex=\"-1\"\n            .language=${this.language}\n            .code=${this.value}\n            wrap=${this.wrap}\n            .highlighter=${this.highlighter}\n            .disableLineNumbers=${this.disableLineNumbers}\n            .preserveWhitespace=${this.preserveWhitespace}\n            .highlightLines=${`{${this.hasFocused ? this.currentLineNumber : \"\"}}`}\n            @focus=${() => {\n              this.textarea?.focus();\n            }}\n            @touchstart=${(/** @type {Event} */ e) => {\n              // Don't let a user focus on this area.\n              this.textarea?.focus();\n            }}\n            @click=${(/** @type {Event} */ e) => {\n              // Don't let a user focus on this area.\n              this.textarea?.focus();\n            }}\n          ></light-code>\n\n          <!-- IMPORTANT! There must be no white-space above. -->\n          <textarea\n            id=\"textarea-${language}\"\n            ${ref(this.textareaChanged)}\n            data-code-lang=${language}\n            part=\"textarea textarea-${language}\"\n            spellcheck=\"false\"\n            autocorrect=\"off\"\n            autocapitalize=\"off\"\n            minlength=${this.minLength}\n            maxlength=${this.maxLength}\n            translate=\"no\"\n            .defaultValue=${this.defaultValue}\n            .value=${this.value}\n            ?disabled=${this.disabled}\n            ?required=${this.required}\n            placeholder=${this.placeholder}\n            @keyup=${this.keyupHandler}\n            @keydown=${this.keydownHandler}\n            @focus=${() => {\n              this.hasFocused = true;\n              this.syncScroll();\n              this.setCurrentLineHighlight();\n              this.dispatchEvent(\n                new Event(\"light-focus\", { bubbles: true, composed: true }),\n              );\n            }}\n            @blur=${() => {\n              this.setAttribute(\"data-has-interacted\", \"\");\n              this.syncScroll();\n              this.setCurrentLineHighlight();\n              this.dispatchEvent(\n                new Event(\"light-blur\", { bubbles: true, composed: true }),\n              );\n            }}\n            @selectionchange=${\n              /** @param {Event} e */ (e) => {\n                this.syncScroll();\n                this.setCurrentLineHighlight();\n                this.dispatchEvent(\n                  new Event(\"light-selectionchange\", {\n                    bubbles: true,\n                    composed: true,\n                  }),\n                );\n              }\n            }\n            @click=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @touchstart=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @touchend=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @pointerdown=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @pointerup=${() => {\n              this.setCurrentLineHighlight();\n            }}\n            @input=${\n              /** @param {Event} e */ (e) => {\n                this.value = /** @type {HTMLTextAreaElement} */ (\n                  e.currentTarget\n                ).value;\n                this.setCurrentLineHighlight();\n                this.dispatchEvent(\n                  new Event(\"light-input\", { bubbles: true, composed: true }),\n                );\n                this.dispatchEvent(\n                  new Event(\"input\", { bubbles: true, composed: true }),\n                );\n                this.syncScroll();\n              }\n            }\n            @change=${\n              /** @param {Event} e */ (e) => {\n                this.value = /** @type {HTMLTextAreaElement} */ (\n                  e.currentTarget\n                ).value;\n                this.setCurrentLineHighlight();\n                this.syncScroll();\n              }\n            }\n            @scroll=${\n              /** @param {Event} e */ (e) => {\n                this.setCurrentLineHighlight();\n                this.syncScroll();\n              }\n            }\n          ></textarea>\n        </div>\n        <!-- base-editor -->\n      </div>\n      <!-- base -->\n\n      <!-- Hidden slot for holding content -->\n      <slot hidden @slotchange=${this.handleSlotChangeEvent}></slot>\n    `;\n  }\n\n  /**\n   * @ignore\n   * @param {ResizeObserverEntry[]} entries\n   */\n  handleTextAreaResize(entries) {\n    const { target } = entries[0];\n    const { left, right, top, bottom } = entries[0].contentRect;\n    const width = left + right;\n    const height = top + bottom;\n\n    /**\n     * Fires whenever the editor resizes, usually due to zoom in / out\n     */\n    this.dispatchEvent(new LightResizeEvent(\"light-resize\", { height, width }));\n    this.syncScroll();\n  }\n\n  /**\n   * @override\n   * @param {import(\"lit\").PropertyValues<this>} changedProperties\n   */\n  updated(changedProperties) {\n    super.updated(changedProperties);\n\n    this.syncScroll();\n    setTimeout(() => this.setCurrentLineHighlight());\n  }\n\n  /**\n   * Syncs the `<light-code>` element scroll position to the same as the `<textarea>`\n   * @param {boolean} [syncCaret=false] - Whether or not to sync the caret. This is generally reserved for right / left arrow keys because the gutter is `position: sticky;`.\n   * @internal\n   */\n  syncScroll(syncCaret = false) {\n    // TODO: There's probably a lot of caching we can do here to reduce recomputes.\n    /**\n     * @type {undefined | null | HTMLTextAreaElement}\n     */\n    const textarea = this.textarea;\n\n    if (textarea == null) return;\n\n    const lightCode = this.shadowRoot?.querySelector(\"light-code\");\n    const code = lightCode?.shadowRoot?.querySelector(\"code\");\n\n    if (syncCaret) {\n      const { top, left } = this.getCaretPosition();\n      // textarea.scrollTop = top\n      if (left < 60) {\n        textarea.scrollLeft = Math.min(left, textarea.scrollLeft);\n      }\n    }\n\n    if (lightCode) {\n      lightCode.scrollTop = textarea.scrollTop;\n    }\n\n    if (code) {\n      code.scrollLeft = textarea.scrollLeft;\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {Element | undefined} element\n   */\n  textareaChanged(element) {\n    if (!(element instanceof HTMLTextAreaElement)) {\n      return;\n    }\n\n    const textarea = element;\n    this.textarea = textarea;\n    this.formControl = textarea;\n\n    this.textareaResizeObserver = new ResizeObserver((entries) =>\n      this.handleTextAreaResize(entries),\n    );\n    this.textareaResizeObserver.observe(textarea);\n  }\n\n  /**\n   * @ignore\n   * @param {Event} e\n   */\n  handleSlotChangeEvent(e) {\n    // @TODO: Attach mutations observers to update value.\n    /**\n     * @type {HTMLSlotElement}\n     */\n    // @ts-expect-error\n    const slot = e.target;\n\n    const templates = slot.assignedElements({ flatten: true });\n\n    // We only unescape when passed into templates.\n    let code = this.unescapeTags(elementsToString(...templates));\n\n    if (!this.preserveWhitespace) {\n      code = dedent(code.trim());\n    }\n\n    if (code) {\n      this.value = code;\n      this.defaultValue = code;\n      setTimeout(() => this.textarea?.setSelectionRange(0, 0));\n      this.dispatchEvent(\n        new Event(\"light-input\", { bubbles: true, composed: true }),\n      );\n      this.dispatchEvent(\n        new Event(\"light-change\", { bubbles: true, composed: true }),\n      );\n    }\n  }\n\n  /**\n   * @ignore\n   * @param {KeyboardEvent} evt\n   */\n  keyupHandler(evt) {\n    this.setCurrentLineHighlight();\n    // setTimeout is needed for Safari which appears to be \"slow\" to update selection APIs.\n    setTimeout(() => this.setCurrentLineHighlight());\n  }\n\n  /**\n   * @ignore\n   * @param {KeyboardEvent} evt\n   */\n  keydownHandler(evt) {\n    this.setCurrentLineHighlight();\n    // setTimeout is needed for Safari which appears to be \"slow\" to update selection APIs.\n    setTimeout(() => this.setCurrentLineHighlight());\n    this.syncScroll();\n\n    if (evt.key.startsWith(\"Arrow\") || evt.key === \"Backspace\") {\n      this.syncScroll(true);\n    }\n\n    // Let's not trap focus. For now.\n    // if ('Tab' === evt.key) {\n    //   evt.preventDefault()\n    //   target.setRangeText('\\t', target.selectionStart, target.selectionEnd, 'end')\n    //   this.value = target.value\n    //   return\n    // }\n  }\n\n  getCaretPosition() {\n    /* Inspired by https://github.com/component/textarea-caret-position */\n    const beforeCaret = this.shadowRoot?.getElementById(\"before-caret\");\n    const afterCaret = this.shadowRoot?.getElementById(\"after-caret\");\n    const caret = this.shadowRoot?.getElementById(\"caret\");\n    const textarea = this.textarea;\n\n    const fallback = { top: 0, left: 0 };\n\n    if (!beforeCaret) {\n      return fallback;\n    }\n    if (!afterCaret) {\n      return fallback;\n    }\n    if (!caret) {\n      return fallback;\n    }\n    if (!textarea) {\n      return fallback;\n    }\n\n    if (textarea.selectionStart !== textarea.selectionEnd) {\n      return fallback;\n    }\n\n    beforeCaret.textContent = \"\";\n\n    const textLines = this.getLinesToSelectionStart();\n\n    if (!textLines) {\n      return fallback;\n    }\n\n    const currentLineNumber = textLines.length - 1;\n    const beforeCaretText = textLines[currentLineNumber].substring(\n      0,\n      textarea.selectionStart,\n    );\n    beforeCaret.textContent = beforeCaretText;\n\n    return {\n      top: afterCaret.offsetTop - textarea.scrollTop,\n      left: afterCaret.offsetLeft - textarea.scrollLeft,\n    };\n  }\n\n  setCurrentLineHighlight() {\n    const currentLineNumber = this.getCurrentLineNumber();\n\n    if (currentLineNumber != null) {\n      this.currentLineNumber = currentLineNumber + 1;\n    }\n  }\n\n  getLinesToSelectionStart() {\n    const textArea = this.textarea;\n\n    if (!textArea) return;\n\n    const textLines = textArea.value\n      .substring(0, textArea.selectionStart)\n      .split(newLineRegex);\n\n    return textLines;\n  }\n\n  getCurrentLineNumber() {\n    const textLines = this.getLinesToSelectionStart();\n\n    if (!textLines) {\n      return 0;\n    }\n\n    const currentLineNumber = textLines.length - 1;\n    // const currentColumnIndex = textLines[textLines.length-1].length;\n    // console.log(\"Current Line Number \"+ currentLineNumber+\" Current Column Index \"+currentColumnIndex );\n\n    return currentLineNumber;\n  }\n\n  /**\n   * @ignore\n   * @param {string} text\n   */\n  // This gets tricky. We could do this, but it may be unexpected...\n  unescapeTags(text) {\n    // Replace usages of `&lt;/script>` with `</script>`. Match against\n    return text.replaceAll(/&lt;\\/([\\w\\d\\.-_]+)>/g, \"</$1>\");\n  }\n\n  /**\n   * @ignore\n   * Highlighters strip newlines. But you can see new lines in <textarea>, this fixes that.\n   * @param {string} text\n   */\n  injectNewLine(text) {\n    // Handle final newlines (see article)\n    if (text === \"\" || text[text.length - 1] === \"\\n\") {\n      // If the last character is a newline character\n      text += \" \"; // Add a placeholder space character to the final line\n    }\n\n    return text;\n  }\n}\n"],
  "mappings": "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",
  "names": ["styles", "i", "BaseEvent", "name", "options", "LightResizeEvent", "BaseEvent", "name", "options", "newLineRegex", "LightEditor", "LitTextareaMixin", "BaseElement", "createPrismInstance", "dedent", "changedProperties", "response", "finalValue", "options", "gutterWidth", "language", "x", "e", "n", "entries", "target", "left", "right", "top", "bottom", "width", "height", "LightResizeEvent", "syncCaret", "textarea", "lightCode", "code", "element", "templates", "elementsToString", "evt", "beforeCaret", "afterCaret", "caret", "fallback", "textLines", "currentLineNumber", "beforeCaretText", "textArea", "text", "__publicField", "LightCode", "i", "baseStyles", "styles", "theme"]
}
